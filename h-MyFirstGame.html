<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>My First Game: pong - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://file.myfontastic.com/DeXq9523CzrFERZkXSzP7D/icons.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2 class="home"><a href="index.html">Incheon</a></h2><h2>For humans</h2><ul class="tutorials"><li><a href="h-prologue.html">Prologue</a></li><li><a href="h-guide.html">Guide</a></li><li><a href="h-tutorials.html">Tutorials</a><ul><li><a href="h-MyFirstGame.html">My First Game: pong</a></li><li><a href="h-spaceships.html">Spaaace</a></li></ul></li><li><a href="h-furtherreading.html">Further Reading</a></li></ul><h2>For Machines</h2><h3 class="classes">Classes</h3><ul><li><a href="ClientEngine.html">ClientEngine</a><ul class='methods'><li data-type='method'><a href="ClientEngine.html#sendInput">sendInput</a></li></ul></li><li><a href="DynamicObject.html">DynamicObject</a><ul class='methods'><li data-type='method'><a href="DynamicObject.html#init">init</a></li><li data-type='method'><a href="DynamicObject.html#toString">toString</a></li></ul></li><li><a href="GameEngine.html">GameEngine</a><ul class='methods'><li data-type='method'><a href="GameEngine.html#on">on</a></li><li data-type='method'><a href="GameEngine.html#once">once</a></li><li data-type='method'><a href="GameEngine.html#processInput">processInput</a></li><li data-type='method'><a href="GameEngine.html#start">start</a></li></ul></li><li><a href="Renderer.html">Renderer</a><ul class='methods'><li data-type='method'><a href="Renderer.html#addObject">addObject</a></li><li data-type='method'><a href="Renderer.html#draw">draw</a></li><li data-type='method'><a href="Renderer.html#init">init</a></li><li data-type='method'><a href="Renderer.html#removeObject">removeObject</a></li></ul></li><li><a href="Serializer.html">Serializer</a><ul class='methods'><li data-type='method'><a href="Serializer.html#addCustomType">addCustomType</a></li><li data-type='method'><a href="Serializer.html#registerClass">registerClass</a></li></ul></li><li><a href="ServerEngine.html">ServerEngine</a></li></ul><h3 class="events">Events</h3><ul><li><a href="GameEngine.html#event:objectAdded">objectAdded</a></li><li><a href="GameEngine.html#event:objectDestroyed">objectDestroyed</a></li><li><a href="GameEngine.html#event:playerDisconnected">playerDisconnected</a></li><li><a href="GameEngine.html#event:playerJoined">playerJoined</a></li><li><a href="GameEngine.html#event:postStep">postStep</a></li><li><a href="GameEngine.html#event:preStep">preStep</a></li><li><a href="GameEngine.html#event:syncReceived">syncReceived</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">My First Game: pong</h1>
    

    <section>

<header>
    
</header>

<article>
    <h1>Build a Simple Incheon Game</h1><p>This tutorial will guide you in building the simplest
javascript networked game, <a href="https://en.wikipedia.org/wiki/Pong">Pong</a>.  It starts with a walk-through of environment setup,
then proceeds with the writing of client code, server
code, and game logic.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Pong.png/220px-Pong.png" alt="Pong"></p>
<h2>Setting up the Environment</h2><p>The creation of a new game starts by cloning boilerplate code:</p>
<pre class="prettyprint source lang-shell"><code>git clone https://github.com/namel/incheongame.git
cd incheongame
npm install</code></pre><p>You now have the basic directory structure of a game.  Look around.
The boilerplate includes an <code>index.html</code> file, which will be served
to the clients, and a <code>main.js</code> file, which is the entry point of the node server.
The game code is inside the <code>src</code> directory, divided into
sub-directories <code>client</code>, <code>server</code>, and <code>common</code>.</p>
<h2>Step 1: Create the Game Object Classes</h2><p>We have two kinds of objects in Pong, the paddle and the ball.
These files extend the <code>DynamicObject</code> class, but are quite simple.
The boilerplate includes a sample game object class, in the file
<code>src/common/Player.js</code></p>
<p>Create the following two classes in the <code>src/common</code> directory:</p>
<h3>src/common/Paddle.js</h3><p>The Paddle class is a bear-bones object.  It is an exact copy of
the sample <code>Player.js</code> object, except that it is called <code>Paddle</code>.</p>
<pre class="prettyprint source lang-javascript"><code>'use strict';

const DynamicObject  = require('incheon').serialize.DynamicObject;

class Paddle extends DynamicObject {

    constructor(id, x, y) {
        super(id, x, y);
        this.class = Paddle;
    };
}
module.exports = Paddle;</code></pre><h3>src/common/Ball.js</h3><p>The Ball class is only slightly more complicated than the Paddle
class.  It adds two getters, which define &quot;bending&quot; properties.
The bending properties below indicate that the client object's position should
gradually <em>bend</em> towards the server object's position at a rate of 0.1
(10%) each time the server sends position updates.  The client object's
velocity should not bend at all, because the ball's velocity can change
suddenly as it hits a wall or a paddle.
We also give the Ball an initial velocity when it is created.</p>
<pre class="prettyprint source lang-javascript"><code>'use strict';

const DynamicObject = require('incheon').serialize.DynamicObject;

class Ball extends DynamicObject {

    get bendingMultiple() { return 0.1; }
    get velocityBendingMultiple() { return 0; }

    constructor(id, x, y) {
        super(id, x, y);
        this.class = Ball;
        this.velocity.set(2, 2);
    };
}
module.exports = Ball;</code></pre><h2>Step 2: Implement the MyGameEngine class</h2><p>The game engine class runs on both the server and the client,
and executes the game's logic.  The client runs the game engine to
predict what will happen, but the server execution is the true
game progress, overriding what the clients might have predicted.</p>
<p>For Pong, we will need to bounce the ball around the board, and check if it
hit a paddle.  We will also need to respond to the up/down inputs.</p>
<h3>src/common/MyGameEngine.js</h3><p>The MyGameEngine class implements the actual logic of the game.
It does the following:</p>
<ul>
<li><strong>start</strong>: define the &quot;world&quot; settings, and register the game logic to run as a post-step function.
Modify the start method to match the following:</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>start() {

    super.start();

    this.worldSettings = {
        width: 400,
        height: 400,
        paddleWidth: 10,
        paddleHeight: 50,
        paddlePadding: 20
    };

    this.on('postStep', () => { this.postStepHandleBall(); });
};</code></pre><ul>
<li><strong>processInput</strong>: handle user inputs by moving the paddle up or down.
Modify the processInput method to match the following:</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>processInput(inputData, playerId) {

    super.processInput(inputData, playerId);

    // get the player paddle tied to the player socket
    var playerPaddle;

    for (let objId in this.world.objects) {
        if (this.world.objects[objId].playerId == playerId) {
            playerPaddle = this.world.objects[objId];
            break;
        }
    }
    if (playerPaddle) {
        if (inputData.input === 'up') {
            playerPaddle.y -= 5;
        } else if (inputData.input === 'down') {
            playerPaddle.y += 5;
        }
    }
};</code></pre><ul>
<li><strong>initGame</strong>: create two paddles, a ball, and add these objects to the game world.
Add the following initGame method:</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>initGame() {
    // create the paddle objects
    this.player1Paddle = new Paddle(++this.world.idCount, this.worldSettings.paddlePadding, 0);
    this.player2Paddle = new Paddle(++this.world.idCount, this.worldSettings.width - this.worldSettings.paddlePadding, 0);
    this.ball = new Ball(++this.world.idCount, this.worldSettings.width / 2, this.worldSettings.height / 2);

    // associate paddels with the right players
    this.player1Paddle.playerId = 0;
    this.player2Paddle.playerId = 1;

    // add paddle objects to the game world
    this.addObjectToWorld(this.player1Paddle);
    this.addObjectToWorld(this.player2Paddle);
    this.addObjectToWorld(this.ball);
}</code></pre><ul>
<li><strong>attachPaddle</strong>: when the first player connects, he becomes the left paddle.  When a second player connects he becomes the right paddle.  Add the following method:</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>attachPaddle(paddleId, playerId) {
    // which player?
    if (paddleId === 0) {
        this.player1Paddle.playerId = playerId;
    } else if (paddleId === 1) {
        this.player2Paddle.playerId = playerId;
    }
}</code></pre><ul>
<li><strong>postStepHandleBall</strong>: this method is executed after the ball has moved.  Check if the ball has hit a wall, or a paddle, and if a player has scored.  First add the object constructors at the top of the file:</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>const Paddle = require('./Paddle');
const Ball = require('./Ball');</code></pre><p>Now add the following methods:</p>
<pre class="prettyprint source lang-javascript"><code>postStepHandleBall() {
    if (this.ball) {

        // LEFT EDGE:
        if (this.ball.x &lt;= this.worldSettings.paddlePadding + this.worldSettings.paddleWidth &&
                this.ball.y >= this.player1Paddle.y &&
                this.ball.y &lt;= this.player1Paddle.y + this.worldSettings.paddleHeight &&
                this.ball.velocity.x &lt; 0) {

            // ball moving left hit player 1 paddle
            this.ball.velocity.x *= -1;
            this.ball.x = this.worldSettings.paddlePadding + this.worldSettings.paddleWidth + 1;
        } else if (this.ball.x &lt;= 0) {

            // ball hit left wall
            this.ball.velocity.x *= -1;
            this.ball.x = 0;
            this.player2Score();
            console.log(`player 2 scored`);
        }

        // RIGHT EDGE:
        if (this.ball.x >= this.worldSettings.width - this.worldSettings.paddlePadding - this.worldSettings.paddleWidth &&
            this.ball.y >= this.player2Paddle.y &&
            this.ball.y &lt;= this.player2Paddle.y + this.worldSettings.paddleHeight &&
            this.ball.velocity.x > 0) {

            // ball moving right hits player 2 paddle
            this.ball.velocity.x *= -1;
            this.ball.x = this.worldSettings.width - this.worldSettings.paddlePadding - this.worldSettings.paddleWidth - 1;
        } else if (this.ball.x >= this.worldSettings.width ) {

            // ball hit right wall
            this.ball.velocity.x *= -1;
            this.ball.x = this.worldSettings.width - 1;
            this.player1Score();
            console.log(`player 1 scored`);
        }

        // ball hits top
        if (this.ball.y &lt;= 0) {
            this.ball.y = 1;
            this.ball.velocity.y *= -1;
        } else if (this.ball.y >= this.worldSettings.height) {
            // ball hits bottom
            this.ball.y = this.worldSettings.height - 1;
            this.ball.velocity.y *= -1;
        }
    }
};

player1Score() {}
player2Score() {}</code></pre><p>The end result should be this <a href="https://github.com/OpherV/netpong/blob/master/src/common/NetpongGameEngine.js">file</a>.</p>
<h2>Step 3: Extend the MyServerEngine Class</h2><p>The server engine will need to register the classes (<code>Ball</code> and <code>Paddle</code>)
with the serializer, so that they can be sent over the network.
This happens in the constructor.  It must initialize the game engine
when the game is started, and handle player connections and disconnections.</p>
<h3>src/server/MyServerEngine.js</h3><pre class="prettyprint source lang-javascript"><code>'use strict';

const ServerEngine = require('incheon').ServerEngine;

class MyServerEngine extends ServerEngine {

    constructor(io, gameEngine, inputOptions){
        super(io, gameEngine, inputOptions);

        this.serializer.registerClass(require('../common/Paddle'));
        this.serializer.registerClass(require('../common/Ball'));
    };

    start(){
        super.start();

        this.gameEngine.initGame();

        this.players = {
            player1: null,
            player2: null
        };
    };

    onPlayerConnected(socket){
        super.onPlayerConnected(socket);

        // attach newly connected player an available paddle
        if (this.players.player1 === null){
            this.players.player1 = socket.id;
            this.gameEngine.attachPaddle(0, socket.playerId);
        } else if (this.players.player2 === null) {
            this.players.player2 = socket.id;
            this.gameEngine.attachPaddle(1, socket.playerId);
        }
    };

    onPlayerDisconnected(socketId, playerId){
        super.onPlayerDisconnected(socketId, playerId);

        if (this.players.player1 == socketId){
            console.log(&quot;Player 1 disconnected&quot;);
            this.players.player1 = null;
        } else if (this.players.player2 == socketId){
            console.log(&quot;Player 2 disconnected&quot;);
            this.players.player2 = null;
        }
    };
}

module.exports = MyServerEngine;</code></pre><h2>Step 4: the Client Code</h2><p>The client-side code must implement a renderer, and a client engine.</p>
<p>The renderer, in our case, will simply update HTML elements created for
each paddle and the ball:</p>
<h3>src/client/MyRenderer.js</h3><pre class="prettyprint source lang-js"><code>'use strict';

const Renderer = require('incheon').render.Renderer;
const Paddle = require('../common/Paddle');
const Ball = require('../common/Ball');

class MyRenderer extends Renderer {

    constructor(gameEngine) {

        super(gameEngine);
        this.sprites = {};

        // TODO: the world settings are really a property of the GameEngine.
        //       but they are currently used by interpolate function of DynamicObject.
        this.worldSettings = {
            width: 400,
            height: 400
        };
    }

    init() {
    }

    draw() {
        super.draw();

        // note - animating via the top attribute of a DOM element is a usually
        // bad practice, but used here for code brevity
        for (let objId of Object.keys(this.sprites)) {
            if (this.sprites[objId].el) {
                this.sprites[objId].el.style.top = this.gameEngine.world.objects[objId].y + 'px';
                this.sprites[objId].el.style.left = this.gameEngine.world.objects[objId].x + 'px';
            }
        }
    }

    addObject(objData, options) {
        let sprite = {};

        if (objData.class == Paddle) {
            sprite.playerId = objData.playerId;

            console.log(objData);

            if (objData.id == 1) {
                sprite.el = document.querySelector('.player1Paddle');
            } else if (objData.id == 2) {
                sprite.el = document.querySelector('.player2Paddle');
            }
        } else if (objData.class == Ball) {
            sprite.el = document.querySelector('.ball');
        }

        this.sprites[objData.id] = sprite;
        return sprite;
    }

    removeObject(obj) {
    }

}

module.exports = MyRenderer;</code></pre><p>The client engine must register the Paddle and Ball classes just like the
server did, and keep references to the objects created.</p>
<h3>src/client/MyClientEngine.js</h3><pre class="prettyprint source lang-js"><code>const ClientEngine = require('incheon').ClientEngine;
const Synchronizer = require('incheon').Synchronizer;
const MyRenderer = require('../client/MyRenderer');

const Paddle = require('../common/Paddle');
const Ball = require('../common/Ball');

class MyClientEngine extends ClientEngine {

    constructor(gameEngine, options) {
        super(gameEngine, options);

        // initialize renderer
        this.renderer = new MyRenderer(gameEngine);

        // initialize object synchronization
        const syncOptions = {
            extrapolate: {
                localObjBending: 0.0,
                remoteObjBending: 0.6
            }
        };
        const synchronizer = new Synchronizer(this, syncOptions);
        synchronizer.extrapolateObjectSelector = () => { return true; };

        this.serializer.registerClass(Paddle);
        this.serializer.registerClass(Ball);
        this.gameEngine.on('client.preStep', this.preStep.bind(this));

        this.gameEngine.on('objectAdded', (object) => {
            if (object.id == 1) {
                this.gameEngine.player1Paddle = object;
            } else if (object.id == 2) {
                this.gameEngine.player2Paddle = object;
            } else if (object.class == Ball) {
                this.gameEngine.ball = object;
            }

        });

        // keep a reference for key press state
        this.pressedKeys = {
            down: false,
            up: false,
            left: false,
            right: false,
            space: false
        };

        document.onkeydown = (e) => { onKeyChange.call(this, e, true); };
        document.onkeyup = (e) => { onKeyChange.call(this, e, false); };
    }

    // our pre-step is to process all inputs
    preStep() {

        if (this.pressedKeys.up) {
            this.sendInput('up', { movement: true });
        }

        if (this.pressedKeys.down) {
            this.sendInput('down', { movement: true });
        }

        if (this.pressedKeys.left) {
            this.sendInput('left', { movement: true });
        }

        if (this.pressedKeys.right) {
            this.sendInput('right', { movement: true });
        }

        if (this.pressedKeys.space) {
            this.sendInput('space', { movement: true });
        }
    }
}

function onKeyChange(e, isDown) {
    e = e || window.event;

    if (e.keyCode == '38') {
        this.pressedKeys.up = isDown;
    } else if (e.keyCode == '40') {
        this.pressedKeys.down = isDown;
    } else if (e.keyCode == '37') {
        this.pressedKeys.left = isDown;
    } else if (e.keyCode == '39') {
        this.pressedKeys.right = isDown;
    } else if (e.keyCode == '32') {
        this.pressedKeys.space = isDown;
    }
}

module.exports = MyClientEngine;</code></pre><h2>Step 4: the Client Visuals</h2><p>The client visuals code are simple HTML objects so we don't discuss them in detail.  See the  <a href="https://github.com/namel/incheongame/blob/netpong/index.html">HTML</a>  and <a href="https://github.com/namel/incheongame/blob/netpong/stylesheets/style.css">CSS</a>.</p>
<h2>Step 5: Running the Game</h2><p>Once everything has been put together the end result should look like
the following <a href="https://github.com/opherv/netpong">repository</a>.</p>
<p>To get a working copy, run:</p>
<pre class="prettyprint source lang-shell"><code>git clone https://github.com/opherv/netpong.git
cd netpong
npm install</code></pre><p>To run the game you must first build the javascript bundle.  The <code>npm install</code>
command above already did this for you, but if you change code, you can rebuild by
executing:</p>
<pre class="prettyprint source lang-shell"><code>npm run postinstall</code></pre><p>To run the game, type:</p>
<pre class="prettyprint source lang-shell"><code>npm start</code></pre><p>Open two browser windows and point them to the local host.  The URL is
<code>http://127.0.0.1:3000/</code> on windows, and <code>http://localhost:3000/</code>
on a Mac.</p>
<h2>Next Steps</h2><p>Your next steps might be to get a deeper understanding by going through
the Spaceships Tutorial, which introduces the concepts and components
of an Incheon networked game.</p>
</article>

</section>

<style>
#main > h1{ display: none }
</style>

</div>

<br class="clear">

<footer>

</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-88335360-1', 'auto');
  ga('send', 'pageview');

</script>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>