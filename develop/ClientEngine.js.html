<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ClientEngine.js - Documentation</title>


    <link rel="shortcut icon" href="http://incheon.gg/favicon.ico">
    <link rel="icon" sizes="16x16 32x32 64x64" href="http://incheon.gg/favicon.ico">
    <link rel="icon" type="image/png" sizes="196x196" href="http://incheon.gg/favicon-192.png">
    <link rel="icon" type="image/png" sizes="160x160" href="http://incheon.gg/favicon-160.png">
    <link rel="icon" type="image/png" sizes="96x96" href="http://incheon.gg/favicon-96.png">
    <link rel="icon" type="image/png" sizes="64x64" href="http://incheon.gg/favicon-64.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http://incheon.gg/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://incheon.gg/favicon-16.png">
        
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://file.myfontastic.com/DeXq9523CzrFERZkXSzP7D/icons.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.8.0/styles/atelier-sulphurpool-light.min.css">
</head>
<body>

    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger" class="navicon-button x">
      <div class="navicon"></div>
    </label>

    <label for="nav-trigger" class="overlay"></label>

    <nav>
        <h2 class="home"><a href="index.html">Incheon</a></h2><h2>Concepts</h2><ul class="tutorials"><li><a href="tutorial-prologue.html">Prologue</a></li><li><a href="tutorial-guide.html">Architecture of a Multiplayer Game</a><ul><li><a href="tutorial-guide_gameengine.html">Game Engine</a></li><li><a href="tutorial-guide_serverengine.html">Server Engine</a></li><li><a href="tutorial-guide_clientengine.html">Client Engine</a></li><li><a href="tutorial-guide_renderer.html">Renderer</a></li><li><a href="tutorial-guide_gameworld.html">Game World and Game Objects</a></li><li><a href="tutorial-guide_serialization.html">Serialization and Communication</a></li></ul></li><li><a href="tutorial-guide_synchronization_methods.html">Synchronization Methods</a><ul><li><a href="tutorial-guide_syncinterpolation.html">Interpolation</a></li><li><a href="tutorial-guide_syncextrapolation.html">Extrapolation</a></li></ul></li><li><a href="tutorial-tutorials.html">Tutorials</a><ul><li><a href="tutorial-MyFirstGame.html">My First Game: Pong</a></li><li><a href="tutorial-spaceships.html">Spaaace</a></li></ul></li><li><a href="tutorial-guide_tuningdebugging.html">Fine Tuning and Debugging</a></li><li><a href="tutorial-furtherreading.html">Further Reading</a></li></ul><h2>API Reference</h2><h3 class="classes">Classes</h3><ul><li><a href="ClientEngine.html">ClientEngine</a><ul class='methods'><li data-type='method'><a href="ClientEngine.html#connect">connect</a></li><li data-type='method'><a href="ClientEngine.html#sendInput">sendInput</a></li><li data-type='method'><a href="ClientEngine.html#start">start</a></li></ul></li><li><a href="DynamicObject.html">DynamicObject</a><ul class='methods'><li data-type='method'><a href="DynamicObject.html#init">init</a></li><li data-type='method'><a href="DynamicObject.html#toString">toString</a></li></ul></li><li><a href="GameEngine.html">GameEngine</a><ul class='methods'><li data-type='method'><a href="GameEngine.html#on">on</a></li><li data-type='method'><a href="GameEngine.html#once">once</a></li><li data-type='method'><a href="GameEngine.html#processInput">processInput</a></li><li data-type='method'><a href="GameEngine.html#removeListener">removeListener</a></li><li data-type='method'><a href="GameEngine.html#start">start</a></li></ul></li><li><a href="Renderer.html">Renderer</a><ul class='methods'><li data-type='method'><a href="Renderer.html#addObject">addObject</a></li><li data-type='method'><a href="Renderer.html#draw">draw</a></li><li data-type='method'><a href="Renderer.html#init">init</a></li><li data-type='method'><a href="Renderer.html#removeObject">removeObject</a></li></ul></li><li><a href="Serializer.html">Serializer</a><ul class='methods'><li data-type='method'><a href="Serializer.html#addCustomType">addCustomType</a></li><li data-type='method'><a href="Serializer.html#registerClass">registerClass</a></li></ul></li><li><a href="ServerEngine.html">ServerEngine</a></li></ul><h3 class="events">Events</h3><ul><li><a href="GameEngine.html#event:client__postInput">client__postInput</a></li><li><a href="GameEngine.html#event:client__postStep">client__postStep</a></li><li><a href="GameEngine.html#event:client__preInput">client__preInput</a></li><li><a href="GameEngine.html#event:client__preStep">client__preStep</a></li><li><a href="GameEngine.html#event:client__syncReceived">client__syncReceived</a></li><li><a href="GameEngine.html#event:objectAdded">objectAdded</a></li><li><a href="GameEngine.html#event:objectDestroyed">objectDestroyed</a></li><li><a href="GameEngine.html#event:playerDisconnected">playerDisconnected</a></li><li><a href="GameEngine.html#event:playerJoined">playerJoined</a></li><li><a href="GameEngine.html#event:postStep">postStep</a></li><li><a href="GameEngine.html#event:preStep">preStep</a></li><li><a href="GameEngine.html#event:server__inputReceived">server__inputReceived</a></li><li><a href="GameEngine.html#event:server__postStep">server__postStep</a></li><li><a href="GameEngine.html#event:server__preStep">server__preStep</a></li><li><a href="GameEngine.html#event:syncReceived">syncReceived</a></li></ul>
    </nav>

    <div id="main">
        
        <h1 class="page-title">ClientEngine.js</h1>
        

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var io = require("socket.io-client");
const Serializer = require('./serialize/Serializer');
const NetworkTransmitter = require('./network/NetworkTransmitter');
const NetworkMonitor = require('./network/NetworkMonitor');
const Synchronizer = require('./Synchronizer');

const STEP_DRIFT_THRESHOLD = 10;
const GAME_UPS = 60;

/**
 * The client engine is the singleton which manages the client-side
 * process, starting the game engine, listening to network messages,
 * starting client steps, and handling world updates which arrive from
 * the server.
 */
class ClientEngine {

    /**
      * Create a client engine instance.
      *
      * @param {GameEngine} gameEngine - a game engine
      * @param {Object} inputOptions - options object
      * @param {Boolean} inputOptions.autoConnect - if true, the client will automatically attempt connect to server.
      * @param {Number} inputOptions.delayInputCount - if set, inputs will be delayed by this many steps before they are actually applied on the client.
      * @param {Number} inputOptions.healthCheckInterval - health check message interval (millisec).  Default is 1000.
      * @param {Number} inputOptions.healthCheckRTTSample - health check RTT calculation sample size.  Default is 10.
      * @param {Object} inputOptions.syncOptions - an object describing the synchronization method.  If not set, will be set to extrapolate, with local object bending set to 0.0 and remote object bending set to 0.6.  If the query-string parameter "sync" is defined, then that value is passed to this object's sync attribute.
      * @param {String} inputOptions.syncOptions.sync - chosen sync option, can be interpolate, extrapolate, or frameSync
      * @param {Number} inputOptions.syncOptions.localObjBending - amount of bending towards original client position, after each sync, for local objects
      * @param {Number} inputOptions.syncOptions.remoteObjBending - amount of bending towards original client position, after each sync, for remote objects
      */
    constructor(gameEngine, inputOptions) {

        this.options = Object.assign({
            autoConnect: true,
            healthCheckInterval: 1000,
            healthCheckRTTSample: 10
        }, inputOptions);

        /**
         * reference to serializer
         * @member {Serializer}
         */
        this.serializer = new Serializer();

        /**
         * reference to game engine
         * @member {GameEngine}
         */
        this.gameEngine = gameEngine;
        this.networkTransmitter = new NetworkTransmitter(this.serializer);

        this.networkMonitor = new NetworkMonitor();

        this.inboundMessages = [];
        this.outboundMessages = [];

        /**
        * client's player ID, as a string.
        * @member {String}
        */
        this.playerId = NaN;

        this.configureSynchronization();

        // create a buffer of delayed inputs (fifo)
        if (inputOptions &amp;&amp; inputOptions.delayInputCount) {
            this.delayedInputs = [];
            for (let i = 0; i &lt; inputOptions.delayInputCount; i++)
                this.delayedInputs[i] = [];
        }

        // when objects get added, tag them as playerControlled if necessary
        this.gameEngine.on('objectAdded', (object) => {
            object.isPlayerControlled = (this.playerId == object.playerId);
        });
    }

    configureSynchronization() {

        // the reflect syncronizer is just interpolate strategy,
        // configured to show server syncs
        let syncOptions = this.options.syncOptions;
        if (syncOptions.sync === 'reflect') {
            syncOptions.sync = 'interpolate';
            syncOptions.reflect = true;
        }
        const synchronizer = new Synchronizer(this, syncOptions);

        // TODO: mixing different strategies together doesn't
        //     really make sense, so we need to refactor the code
        //     below.
        if (syncOptions.sync === 'extrapolate')
            synchronizer.extrapolateObjectSelector = () => { return true; };
        else if (syncOptions.sync === 'interpolate')
            synchronizer.interpolateObjectSelector = () => { return true; };
        else if (syncOptions.sync === 'frameSync')
            synchronizer.frameSyncSelector = () => { return true; };
    }

    /**
     * Makes a connection to the game server
     *
     * @return {Promise} Resolved when the connection is made to the server
     */
    connect() {
        let connectionPromise = new Promise((resolve, reject) => {
            this.socket = io(this.options.serverURL);

            this.networkMonitor.registerClient(this);

            this.socket.once("connect", () => {
                console.log("connection made");
                resolve();
            });

            this.socket.on('playerJoined', (playerData) => {
                this.playerId = playerData.playerId;
                this.messageIndex = Number(this.playerId) * 10000;
            });

            this.socket.on('worldUpdate', (worldData) => {
                this.inboundMessages.push(worldData);
            });
        });

        return connectionPromise;
    }

    /**
     * Start the client engine, setting up the game loop, rendering loop and renderer.
     *
     * @return {Promise} Resolves once the Renderer has been initialized, and the game is
     * ready to connect
     */
    start() {
        // Simple JS game loop adapted from
        // http://nokarma.org/2011/02/02/javascript-game-development-the-game-loop/
        let skipTicks = 1000 / GAME_UPS;
        let nextGameTick = (new Date()).getTime();

        // the game loop ensures a fixed number of steps per second
        let gameLoop = () => {
            while ((new Date()).getTime() > nextGameTick) {
                this.step();
                nextGameTick += skipTicks;
            }
            window.requestAnimationFrame(gameLoop);
        };

        // the render loop waits for next animation frame
        let renderLoop = () => {
            this.renderer.draw();
            window.requestAnimationFrame(renderLoop);
        };

        // start game, game loop, render loop
        this.gameEngine.start();
        window.requestAnimationFrame(gameLoop);

        // initialize the renderer
        if (!this.renderer) {
            alert('ERROR: game has not defined a renderer');
        }

        return this.renderer.init().then(() => {
            window.requestAnimationFrame(renderLoop);

            if (this.options.autoConnect) {
                this.connect();
            }

        });
    }

    step() {

        // first update the trace state
        this.gameEngine.trace.setStep(this.gameEngine.world.stepCount + 1);

        // skip one step if requested
        if (this.skipOneStep === true) {
            this.skipOneStep = false;
            return;
        }

        this.gameEngine.emit('client__preStep');
        while (this.inboundMessages.length > 0) {
            this.handleInboundMessage(this.inboundMessages.pop());
        }

        // check for server/client step drift
        if (this.gameEngine.serverStep) {
            if (this.gameEngine.world.stepCount > this.gameEngine.serverStep + STEP_DRIFT_THRESHOLD) {
                this.gameEngine.trace.warn(`step drift.  Client is ahead of server.  Client will skip a step.`);
                this.skipOneStep = true;
            } else if (this.gameEngine.serverStep > this.gameEngine.world.stepCount + STEP_DRIFT_THRESHOLD) {
                this.gameEngine.trace.warn(`step drift.  Client is behind server.`);
                this.doubleStep = true;
            }
        }

        // perform game engine step
        this.handleOutboundInput();
        this.applyDelayedInputs();
        this.gameEngine.step();
        this.gameEngine.emit('client__postStep');

        if (this.gameEngine.trace.length &amp;&amp; this.socket) {
            // socket might not have been initialized at this point
            this.socket.emit("trace", JSON.stringify(this.gameEngine.trace.rotate()));
        }
    }

    doInputLocal(message) {
        if (this.gameEngine.passive) {
            return;
        }

        this.gameEngine.emit('client__preInput', message.data);
        this.gameEngine.processInput(message.data, this.playerId);
        this.gameEngine.emit('client__postInput', message.data);
    }

    applyDelayedInputs() {
        if (!this.delayedInputs) {
            return;
        }
        let that = this;
        let delayed = this.delayedInputs.shift();
        if (delayed &amp;&amp; delayed.length) {
            delayed.forEach(that.doInputLocal.bind(that));
        }
        this.delayedInputs.push([]);
    }

    /**
     * This function should be called by the client whenever a user input
     * occurs.  This function will emit the input event,
     * forward the input to the client's game engine (with a delay if
     * so configured) and will transmit the input to the server as well.
     *
     * This function can be called by the extended client engine class,
     * typically at the beginning of client-side step processing (see event client__preStep)
     *
     * @param {Object} input - string representing the input
     * @param {Object} inputOptions - options for the input
     */
    sendInput(input, inputOptions) {
        var message = {
            command: 'move',
            data: {
                messageIndex: this.messageIndex,
                step: this.gameEngine.world.stepCount,
                input: input,
                options: inputOptions
            }
        };

        this.gameEngine.trace.info(`USER INPUT[${this.messageIndex}]: ${input} ${inputOptions ? JSON.stringify(inputOptions) : '{}'}`);

        // if we delay input application on client, then queue it
        // otherwise apply it now
        if (this.delayedInputs) {
            this.delayedInputs[this.delayedInputs.length - 1].push(message);
        } else {
            this.doInputLocal(message);
        }
        this.outboundMessages.push(message);

        this.messageIndex++;
    }

    handleInboundMessage(syncData) {

        let syncEvents = this.networkTransmitter.deserializePayload(syncData).events;

        // TODO: this should be done in a better way.
        // derive stepCount by taking the max of all events
        let maxStepCount = syncEvents.reduce((max, el) => {
            return el.stepCount ? Math.max(max, el.stepCount) : max;
        }, 0);

        // emit that a snapshot has been received
        this.gameEngine.emit('client__syncReceived', {
            syncEvents: syncEvents,
            stepCount: maxStepCount
        });

        this.gameEngine.trace.info(`========== inbound world update ${this.gameEngine.world.stepCount} ==========`);

        // finally update the stepCount
        if (maxStepCount > this.gameEngine.world.stepCount) {
            this.gameEngine.world.stepCount = maxStepCount;
            this.gameEngine.trace.info(`========== world step count updated to  ${maxStepCount} ==========`);
        }
    }

    handleOutboundInput() {
        for (var x = 0; x &lt; this.outboundMessages.length; x++) {
            this.socket.emit(this.outboundMessages[x].command, this.outboundMessages[x].data);
        }
        this.outboundMessages = [];
    }

}

module.exports = ClientEngine;
</code></pre>
        </article>
    </section>




    </div>

    <br class="clear">

    <footer>

    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-88335360-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script src="https://use.typekit.net/lai1bbe.js"></script>
    <script>try{Typekit.load({ async: true });}catch(e){}</script>


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <script src="scripts/linenumber.js"></script>
</body>
</html>
